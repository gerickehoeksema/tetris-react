{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill([0, 'clear']));\nexport const checkCollision = (player, stage, {\n  x: moveX,\n  y: moveY\n}) => {\n  for (var y = 0; y < player.tetromino.length; y++) {\n    for (var x = 0; x < player.tetromino[0].length; x++) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        // 2. Check that our move is inside the game areas height (y)\n        if ( // We shouldn't go through the bottom of the play area\n        !stage[y + player.pos.y + moveY] || // 3. Check that our move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] || // 4. Check that the cell we're moving to isn't set to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["D:/Projects 2/tetris-react/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAApB;AACP,OAAO,MAAMC,YAAY,GAAG,EAArB;AAEP,OAAO,MAAMC,WAAW,GAAG,MAAMC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,EAAgC,MAAM,IAAIE,KAAJ,CAAUH,WAAV,EAAuBK,IAAvB,CAA4B,CAAC,CAAD,EAAG,OAAH,CAA5B,CAAtC,CAA1B;AAEP,OAAO,MAAMC,cAAc,GAAG,CAACC,MAAD,EAASC,KAAT,EAAgB;AAACC,EAAAA,CAAC,EAAEC,KAAJ;AAAWC,EAAAA,CAAC,EAAEC;AAAd,CAAhB,KAA0C;AACpE,OAAI,IAAID,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,MAAM,CAACM,SAAP,CAAiBC,MAApC,EAA4CH,CAAC,EAA7C,EAAiD;AAC7C,SAAI,IAAIF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,MAAM,CAACM,SAAP,CAAiB,CAAjB,EAAoBC,MAAvC,EAA+CL,CAAC,EAAhD,EAAoD;AAChD;AACA,UAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBF,CAApB,MAA2B,CAA9B,EAAiC;AAC7B;AACA,aACA;AACA,SAACD,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAN,IACA;AACA,SAACJ,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,CAFD,IAGA;AACAF,QAAAA,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,EAA0D,CAA1D,MAAiE,OANjE,EAOE;AACE,iBAAO,IAAP;AACH;AACJ;AACJ;AACJ;AAEJ,CApBM","sourcesContent":["export const STAGE_WIDTH = 12;\r\nexport const STAGE_HEIGHT = 20;\r\n\r\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill([0,'clear']))\r\n\r\nexport const checkCollision = (player, stage, {x: moveX, y: moveY }) => {\r\n    for(var y = 0; y < player.tetromino.length; y++) {\r\n        for(var x = 0; x < player.tetromino[0].length; x++) {\r\n            // 1. Check that we're on an actual Tetromino cell\r\n            if(player.tetromino[y][x] !== 0) {\r\n                // 2. Check that our move is inside the game areas height (y)\r\n                if(\r\n                // We shouldn't go through the bottom of the play area\r\n                !stage[y + player.pos.y + moveY] ||\r\n                // 3. Check that our move is inside the game areas width (x)\r\n                !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\r\n                // 4. Check that the cell we're moving to isn't set to clear\r\n                stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear'\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}